[{"title":"Usage details","type":0,"sectionRef":"#","url":"docs/details","content":"","keywords":""},{"title":"Hooks​","type":1,"pageTitle":"Usage details","url":"docs/details#hooks","content":"Hooks are topologically-aware functions. This means that when you use a hook like useState or useEffect, they are aware of the call stack and hold their own state outside of arguments and return values. Their state is actually keyed by your script name and the line number you call them on! This state is kept in the enclosing scope. Scopes are created every time you use a new widget or create children inside of a widget. You can also create a new scope manually with the Plasma.scope function. Even if code runs multiple times in a single frame, state will always be separated by scope. This means you can use the same widget multiple times in a single frame, and their state will be separate because they are all inside of separate scopes. If called in a loop, hooks hold state by number of times that line was called consecutively. Check out the API reference to learn more. "},{"title":"Automatic layout​","type":1,"pageTitle":"Usage details","url":"docs/details#automatic-layout","content":"Widgets are automatically laid out with Roblox's Layout objects. This means you don't need to worry about where UI elements go, they just go after whatever came before them. By default, widgets are laid out vertically. You can lay widgets out horizontally by using Plasma.row(function() end) and creating widgets inside the children function to lay widgets out to the side. In the future, there will be more widgets that allow users to customize layout more easily. Plasma automatically sets the LayoutOrder property of children widgets to the correct value. "},{"title":"Error reporting​","type":1,"pageTitle":"Usage details","url":"docs/details#error-reporting","content":"By default, errors that occur during layout are reported visually in the UI, bounded at the scope level.  Since your code runs every frame, errors that happen every frame can fill up the output quickly. To mitigate this, Plasma will only allow repeated errors to be reported in the output once every 10 seconds:  "},{"title":"Styles","type":0,"sectionRef":"#","url":"docs/styles","content":"","keywords":""},{"title":"useStyle​","type":1,"pageTitle":"Styles","url":"docs/styles#usestyle","content":"Returns the current style information, with styles that are set more recently in the tree overriding styles that were set further up. In this way, styles cascade downwards, similar to CSS. "},{"title":"setStyle​","type":1,"pageTitle":"Styles","url":"docs/styles#setstyle","content":"Defines style for any subsequent calls in this scope. Merges with any existing styles. "},{"title":"Default styles​","type":1,"pageTitle":"Styles","url":"docs/styles#default-styles","content":"By default, these styles are used. You can override them anywhere: { bg1 = Color3.fromRGB(31, 31, 31), bg2 = Color3.fromRGB(42, 42, 42), bg3 = Color3.fromRGB(54, 54, 54), mutedTextColor = Color3.fromRGB(147, 147, 147), textColor = Color3.fromRGB(255, 255, 255), } Copy "},{"title":"Plasma","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"What is immediate mode?​","type":1,"pageTitle":"Plasma","url":"docs/intro#what-is-immediate-mode","content":"Plasma is an immediate mode UI library, as opposed to retained mode. In a retained mode model, you might make a button and connect a clicked event, with code that is invoked when the event happens. The button is retained in the DataModel, and to change the text on it you need to store a reference to it. But under an immediate mode model, you show the button and check if it's been clicked immediately, and you do that every single frame (60 times per second). There's no need for a clicked event or to store a reference to the button. As another example, let's say you had a window that you only wanted to be shown when it was visible. In retained mode, you would create the window, and store a reference to the window. When the button to toggle visibility is toggled, you use the reference to the window to make it visible or not. In immediate mode, it's much simpler: you just check if the window should be rendered with an if statement, and render the window inside the if statement. That's it: if the window wasn't supposed to be rendered, you just never call the code to render the window. "},{"title":"Advantages​","type":1,"pageTitle":"Plasma","url":"docs/intro#advantages","content":"The main advantage of immediate mode is that code becomes vastly simpler: You never need to have any on-click handlers and callbacks that disrupts your code flow.You don't have to worry about a lingering callback calling something that is gone.Your GUI code can easily live in a simple function (no need for an object just for the UI).You don't have to worry about world and GUI state being out-of-sync (i.e. the GUI showing something outdated), because the GUI isn't storing any state - it is showing the latest state immediately. In other words, a whole lot of code, complexity and bugs are gone, and you can focus your time on something more interesting than writing GUI code. "},{"title":"Performance​","type":1,"pageTitle":"Plasma","url":"docs/intro#performance","content":"Your UI code runs every frame, but we only make changes to the DataModel as needed. If you created a window, button, and checkbox in the exact same place last frame, we just do nothing this frame. We only make changes to the DataModel when something ends up being different than the last frame. This means that if your UI is not any different than it was last time, the only overhead you have is actually calling the functions to create the UI. It's not free, and using immediate-mode UI can end up using more CPU time than a retained mode UI, but it's also shouldn't be a significant enough of an overhead to cause problems. Computers are pretty fast. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/getting-started","content":"Getting Started Your UI code is intended to run on every frame. To get started with Plasma, the first step is to set up an event loop: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Players = game:GetService(&quot;Players&quot;) local PlayerGui = Players.LocalPlayer:WaitForChild(&quot;PlayerGui&quot;) local RunService = game:GetService(&quot;RunService&quot;) local Plasma = require(ReplicatedStorage.Plasma) local screenGui = Instance.new(&quot;ScreenGui&quot;) screenGui.Name = &quot;Plasma&quot; screenGui.Parent = PlayerGui local root = Plasma.new(screenGui) RunService.Heartbeat:Connect(function() Plasma.start(root, function() Plasma.window(&quot;Hello plasma!&quot;, function() if Plasma.button(&quot;Say hello&quot;):clicked() then print(&quot;Hello world!&quot;) end end) end) end) Copy In the above code sample, we call Plasma.new, passing in the root instance where we want our UI to end up, in this case it's a ScreenGui. Plasma.new returns an object which holds state about our UI. You don't need to interact with this object, just keep it around so we can pass it into Plasma later. We create an event connected to Heartbeat, and every heartbeat event, we call Plasma.start with our root and a function that creates the UI. The function we pass to Plasma.start cannot yield (doing so will error). Inside, we can create our UI using Plasma's widgets. From here, you should look at the API reference to check out all the other available widgets!","keywords":""},{"title":"Creating Custom Widgets","type":0,"sectionRef":"#","url":"docs/creating-widgets","content":"","keywords":""},{"title":"Only updating properties when necessary with useEffect​","type":1,"pageTitle":"Creating Custom Widgets","url":"docs/creating-widgets#only-updating-properties-when-necessary-with-useeffect","content":"Typically, setting properties every frame is not that expensive of an operation, but if you only wanted to set Text and TextColor3 when their arguments actually changed, we can use the useEffect hook: Plasma.useEffect(function() label.Text = text label.TextColor3 = color end, text, color) Copy Now, this code will only ever be invoked if text or color actually changes from the last run. "},{"title":"Persistent state with the useState hook​","type":1,"pageTitle":"Creating Custom Widgets","url":"docs/creating-widgets#persistent-state-with-the-usestate-hook","content":"Let's make a counter button! The button's text should increase by 1 every time we click it. myButton.lua local Plasma = require(ReplicatedStorage.Plasma) return Plasma.widget(function(text, color) local times, setTimes = Plasma.useState(0) -- new! local label = Plasma.useInstance(function() return Plasma.create(&quot;TextButton&quot;, { -- snip -- Activated = function() -- new! setTimes(function(last) return last + 1 end) end, }) end) label.Text = text .. &quot; &quot; .. times -- new! end) Copy (Extraneous lines have been removed from the above example) Now, every time the user clicks this button, it'll concatenate the text they passed in with the number of times the button's been pressed.  A note on useState with useInstance and useEffect Notice that we pass a function to setTimes. What would have happened if we just wrote setTimes(times + 1) instead? It would only go to 1! This is because (as we mentioned above), the code inside useInstance only ever runs once, when the widget is created. This means that the times variable the useInstance closure captured is always going to be 0. In the main scope of the widget function, times is what you expect, because it does run every frame. But inside useInstance or useEffect functions, times is always going to be what it was when those functions ran. That's why the set callback (setTimes) can be given a function, which is invoked immediately with the current value of times. Problem solved! "},{"title":"Getting information out of widgets​","type":1,"pageTitle":"Creating Custom Widgets","url":"docs/creating-widgets#getting-information-out-of-widgets","content":"Let's say you want your users to be able to see how many times your button was clicked in their code when they use your button widget. You already know how to do this: just return it! At the bottom of your widget, just: return { times = times } Copy tip Returning a table with named values instead of returning a value directly is recommended, because it allows you to add more return values in the future without breaking your API interface. Then, when you use your button widget, you can just check it! Using your widget Plasma.start(root, function() Plasma.window(&quot;Button&quot;, function() local timesClicked = myButton(&quot;hi&quot;, Color3.fromRGB(255, 153, 0)).times if timesClicked &gt; 50 then Plasma.label(&quot;You clicked them all!&quot;) end end) end) Copy "},{"title":"Nested widgets​","type":1,"pageTitle":"Creating Custom Widgets","url":"docs/creating-widgets#nested-widgets","content":"You can use widgets inside of other widgets. For example, you could blur the world only if the number of times clicked is even: if times % 2 == 0 then Plasma.blur(20) end Copy "},{"title":"Automatic size​","type":1,"pageTitle":"Creating Custom Widgets","url":"docs/creating-widgets#automatic-size","content":"Roblox has an automatic size property of GuiObjects, but it doesn't always work correctly, especially with padding. Plasma comes with an alternative automatic sizing function: automaticSize. To use it, just call automaticSize inside your useInstance function, passing in your root frame. "},{"title":"Plasma","type":0,"sectionRef":"#","url":"api/Plasma","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Plasma","url":"api/Plasma#functions","content":" "},{"title":"automaticSize​","type":1,"pageTitle":"Plasma","url":"api/Plasma#automaticSize","content":"utilities &lt;/&gt; Plasma.automaticSize( container: GuiObject ,-- The instance to apply automatic sizing to. options: {axis: Enum.AutomaticSize,maxSize: Vector2 } | nil ) → () Applies padding-aware automatic size to the given GUI instance. This function sets up events to listen to further changes, so should only be called once per object. Also supports ScrollingFrames by correctly clamping actual and canvas sizes.  "},{"title":"create​","type":1,"pageTitle":"Plasma","url":"api/Plasma#create","content":"utilities &lt;/&gt; Plasma.create( className: string,-- The class name of the Instance to create props: CreateProps ) → () A function that creates an Instance tree. CreateProps is a table: String keys are interpreted as properties to set Numerical keys are interpreted as children Function values are interpreted as event handlers create(&quot;Frame&quot;, { BackgroundTransparency = 1, Name = &quot;Checkbox&quot;, create(&quot;TextButton&quot;, { BackgroundColor3 = Color3.fromRGB(54, 54, 54), Size = UDim2.new(0, 30, 0, 30), create(&quot;UICorner&quot;, { CornerRadius = UDim.new(0, 8), }), Activated = function() setClicked(true) end, }),   "},{"title":"new​","type":1,"pageTitle":"Plasma","url":"api/Plasma#new","content":"&lt;/&gt; Plasma.new( rootInstance: Instance -- The root instance of which to mount all children. Likely a ScreenGui. ) → Node-- An opaque object which holds persistent state about your UI.   "},{"title":"createContext​","type":1,"pageTitle":"Plasma","url":"api/Plasma#createContext","content":"&lt;/&gt; Plasma.createContext( name: string-- The human-readable name of the context. This is only for debug purposes. ) → Context-- An opqaue Context object which holds persistent state. Creates a [Context] object which is used to pass state downwards through the tree without needing to thread it through every child as props.  "},{"title":"useContext​","type":1,"pageTitle":"Plasma","url":"api/Plasma#useContext","content":"hooks &lt;/&gt; Plasma.useContext( context: Context-- A context object previously created with createContext ) → T Returns the value of this context provided by the most recent ancestor that used provideContext with this context.  "},{"title":"provideContext​","type":1,"pageTitle":"Plasma","url":"api/Plasma#provideContext","content":"&lt;/&gt; Plasma.provideContext( context: Context,-- A context object previously created with createContext value: T-- Any value you want to provide for this context ) → () Provides a value for this context for any subsequent uses of useContext in this scope.  "},{"title":"useEffect​","type":1,"pageTitle":"Plasma","url":"api/Plasma#useEffect","content":"hooks &lt;/&gt; Plasma.useEffect( callback: () → () | () → () → (),-- A callback function that optionally returns a cleanup function ...: any-- Dependencies ) → () useEffect takes a callback as a parameter which is then only invoked if passed dependencies are different from the last time this function was called. The callback is always invoked the first time this code path is reached. If no dependencies are passed, the callback only runs once. This function can be used to skip expensive work if none of the dependencies have changed since the last run. For example, you might use this to set a bunch of properties in a widget if any of the inputs change.  "},{"title":"useState​","type":1,"pageTitle":"Plasma","url":"api/Plasma#useState","content":"hooks &lt;/&gt; Plasma.useState( initialValue: T-- The value this hook returns if the set callback has never been called ) → ( T,-- The previously set value, or the initial value if none has been set (newValue: T) → ()-- A function which when called stores the value in this hook for the next run ) local checked, setChecked = useState(false) useInstance(function() local TextButton = Instance.new(&quot;TextButton&quot;) TextButton.Activated:Connect(function() setChecked(not checked) end) return TextButton end) TextButton.Text = if checked then &quot;X&quot; else &quot;&quot;   "},{"title":"useInstance​","type":1,"pageTitle":"Plasma","url":"api/Plasma#useInstance","content":"hooks &lt;/&gt; Plasma.useInstance( creator: () → ( Instance , Instance? )-- A callback which creates the widget and returns it ) → Instance -- Returns the instance returned by creator useInstance takes a callback which should be used to create the initial UI for the widget. The callback is only ever invoked on the first time this widget runs and never again. The callback should return the instance it created. The callback can optionally return a second value, which is the instance where children of this widget should be placed. Otherwise, children are placed in the first instance returned. useInstance returns the instance returned by the creator callback on the initial call and all further calls.  "},{"title":"start​","type":1,"pageTitle":"Plasma","url":"api/Plasma#start","content":"&lt;/&gt; Plasma.start( rootNode: Node,-- A node created by Plasma.new. callback: (...: T) → (), ...: T-- Additional parameters to callback ) → () Begins a new frame for this Plasma instance. The callback is invoked immediately. Code run in the callback function that uses plasma APIs will be associated with this Plasma node. The callback function is not allowed to yield.  "},{"title":"scope​","type":1,"pageTitle":"Plasma","url":"api/Plasma#scope","content":"&lt;/&gt; Plasma.scope( callback: (...: T) → (), ...: T-- Additional parameters to callback ) → () Begins a new scope. This function may only be called within a Plasma.start callback. The callback is invoked immediately. Beginning a new scope associates all further calls to Plasma APIs with a nested scope inside this one.  "},{"title":"widget​","type":1,"pageTitle":"Plasma","url":"api/Plasma#widget","content":"&lt;/&gt; Plasma.widget( callback: (...: T) → ()-- The widget function ) → (...: T) → ()-- A function which can be called to create the widget This function takes a widget funtion and returns a function that automatically starts a new scope when the function is called.  "},{"title":"useStyle​","type":1,"pageTitle":"Plasma","url":"api/Plasma#useStyle","content":"style &lt;/&gt; Plasma.useStyle() → () Returns the current style information, with styles that are set more recently in the tree overriding styles that were set further up. In this way, styles cascade downwards, similar to CSS.  "},{"title":"setStyle​","type":1,"pageTitle":"Plasma","url":"api/Plasma#setStyle","content":"style &lt;/&gt; Plasma.setStyle( styleFragment: {[string]: any}-- A dictionary of style information ) → () Defines style for any subsequent calls in this scope. Merges with any existing styles.  "},{"title":"arrow​","type":1,"pageTitle":"Plasma","url":"api/Plasma#arrow","content":"widgets &lt;/&gt; Plasma.arrow( from: Vector3 | CFrame | BasePart , to: Vector3 | BasePart | nil ) → () arrow(from: Vector3, to: Vector3) -&gt; Creates an arrow between from and to arrow(point: Vector3) -&gt; Creates an arrow pointing at point arrow(cframe: CFrame) -&gt; Creates an arrow with its point at the CFrame position facing the CFrame LookVector arrow(part: BasePart) -&gt; Arrow represents the Part's CFrame arrow(fromPart: BasePart, toPart: BasePart) -&gt; Arrow between the two parts Plasma.arrow(Vector3.new(0, 0, 0)) Plasma.arrow(Vector3.new(5, 5, 5), Vector3.new(10, 10, 10))   "},{"title":"blur​","type":1,"pageTitle":"Plasma","url":"api/Plasma#blur","content":"widgets &lt;/&gt; Plasma.blur( size: number-- The size of the blur ) → () A blur effect in the world. Created in Lighting.  "},{"title":"button​","type":1,"pageTitle":"Plasma","url":"api/Plasma#button","content":"widgets &lt;/&gt; Plasma.button( label: string-- The label for the checkbox ) → ButtonWidgetHandle A text button. Returns a widget handle, which has the field: clicked, a function you can call to check if the checkbox was clicked this frame Plasma.window(&quot;Button&quot;, function() if Plasma.button(&quot;button text&quot;):clicked() then print(&quot;clicked!&quot;) end end)   "},{"title":"checkbox​","type":1,"pageTitle":"Plasma","url":"api/Plasma#checkbox","content":"widgets &lt;/&gt; Plasma.checkbox( label: string,-- The label for the checkbox options: {disabled: boolean,checked: boolean} ) → CheckboxWidgetHandle A checkbox. A checkbox may either be controlled or uncontrolled. By passing the checked field in options, you make the checkbox controlled. Controlling the checkbox means that the checked state is controlled by your code. Otherwise, the controlled state is controlled by the widget itself. Returns a widget handle, which has the fields: checked, a function you can call to check if the checkbox is checked clicked, a function you can call to check if the checkbox was clicked this frame Plasma.window(&quot;Checkboxes&quot;, function() if Plasma.checkbox(&quot;Controlled checkbox&quot;, { checked = checked, }):clicked() then checked = not checked end Plasma.checkbox(&quot;Disabled checkbox&quot;, { checked = checked, disabled = true, }) Plasma.checkbox(&quot;Uncontrolled checkbox&quot;) end)   "},{"title":"portal​","type":1,"pageTitle":"Plasma","url":"api/Plasma#portal","content":"widgets &lt;/&gt; Plasma.portal( targetInstance: Instance ,-- Where the portal goes to children: () → ()-- Children ) → () The portal widget creates its children inside the specified targetInstance. For example, you could use this to create lighting effects in Lighting as a widget: return function(size) portal(Lighting, function() useInstance(function() local blur = Instance.new(&quot;BlurEffect&quot;) blur.Size = size return blur end) end) end   "},{"title":"row​","type":1,"pageTitle":"Plasma","url":"api/Plasma#row","content":"widgets &lt;/&gt; Plasma.row( options: {padding: Vector2 }, children: () → ()-- Children ) → () Lays out children horizontally  "},{"title":"spinner​","type":1,"pageTitle":"Plasma","url":"api/Plasma#spinner","content":"widgets &lt;/&gt; Plasma.spinner() → () A spinner widget, indicating loading.  "},{"title":"window​","type":1,"pageTitle":"Plasma","url":"api/Plasma#window","content":"widgets &lt;/&gt; Plasma.window( title: string,-- The title of the window children: () → ()-- Children ) → () A window widget. Contains children. In the future: Closable Draggable Resizable "}]